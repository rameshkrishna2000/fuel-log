import { PayloadAction, createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import URLs from '../../../../../utils/appURLs';
import { updateToast } from '../../../../../common/redux/reducer/commonSlices/toastSlice';
import axiosInstance from '../../../../../app/config/axiosInstance';
import { AxiosResponse } from 'axios';

type ReturnedType = any;

interface UpdateTripBooking {
  tripID: number;
  journeyID: string;
  agentName: string | number;
  guestName: string;
  startTimestamp: number;
  adultCount: number | string;
  childCount: number | string;
  refNumber: string;
  vehicleNumber: string;
}

interface FilterDropdown {
  agents: any;
  tours: any;
}

interface AutoSchedule {
  autoplannerID: number;
  tripMode?: string;
}
interface pdfExcel {
  isLoading: boolean;
  data: any;
  error: string | null;
}
const pdfExcelState: pdfExcel = {
  isLoading: false,
  data: null,
  error: null
};

interface AutoGeneratedTrip {
  adultCount: number;
  agentName: string;
  autoplannerID: number;
  childCount: number;
  currentHashCode: string;
  destination: string;
  endLat: number;
  endLng: number;
  guestName: string;
  journeyID: string;
  mode: string;
  previousHashCode: string;
  refNumber: string;
  source: string;
  startLat: number;
  startLng: number;
  startTimestamp: number;
  timezone: string;
  tripID: number;
  tripTotalDistance: number;
  tripTotalDuration: number;
  vehicleNumber: string;
}

interface Trips {
  vehicleNumber: string;
  date: number;
  tourName: string;
  mode: string;
  id: string;
  isReturnTrip: any;
}

// Define the structure of the data returned by the API
interface AutoGeneratedTripsViewList {
  count: number;
  autoplannerTripsViewList: AutoGeneratedTrip[];
  standardTourOverviewList: any[];
  standardTourBookingInfo: any[];
}

interface AutoGeneratedStatus {
  status: string;
  data: AutoGeneratedTripsViewList | null;
  message: string;
  standardTourBookingInfo: any[];
}

interface UpdateScheduleTrips {
  payload: UpdateTripBooking;
  pageDetails: {
    autoplannerID: number;
    pageNo?: number;
    pageSize?: number;
    tripMode?: string;
  };
}

const initialStateDropDown = {
  isLoading: false,
  data: null,
  error: null
};

// Define the shape of the Redux state
interface AutoGeneratedTripState {
  isLoading: boolean;
  data: any;
  count: any;
  isFilter: boolean;
  error: string | null;
  standardTourBookingInfo: any[];
  statusCount: any;
}

const initialState: AutoGeneratedTripState = {
  isLoading: false,
  data: null,
  count: null,
  error: null,
  statusCount: {},
  isFilter: false,
  standardTourBookingInfo: []
};

interface filterDropdown {
  isLoading: boolean;
  data: any;
  error: string | null;
  tours: [];
  agents: [];
}

const initialStates: filterDropdown = {
  isLoading: false,
  data: [],
  error: null,
  tours: [],
  agents: []
};

// get auto generated trip details
export const autoGeneratedTripsAction = createAsyncThunk<ReturnedType, any>(
  'auto generated trips/trips',
  async (data, thunkApi) => {
    const {
      autoplannerID,
      tripMode,
      pageNo,
      pageSize,
      tourName,
      vehicleNumber,
      agentName
    }: any = data;
    try {
      let url = `${URLs.GET_AUTO_PLANNERTRIP_SCHEDULE}?date=${autoplannerID}&mode=${tripMode}`;
      if (data.PageNo && data.PageSize) {
        url += `&pageNo=${data.PageNo}&pageSize=${data.PageSize}`;
      }
      const optionalParams = [
        { key: 'agentName', value: agentName },
        { key: 'tourName', value: tourName },
        { key: 'vehicleNumber', value: vehicleNumber }
      ];

      optionalParams.forEach(param => {
        if (param.value) {
          url += `&${param.key}=${param.value}`;
        }
      });
      const response = await axiosInstance({
        method: 'GET',
        url: url
      });
      if (response?.data?.status === 'Not found') {
        thunkApi.dispatch(
          updateToast({
            show: true,
            message: 'No trip report on this date',
            severity: 'warning'
          })
        );
      }
      return response?.data;
    } catch (error: any) {
      if (error.response.data?.message) {
        thunkApi.dispatch(
          updateToast({
            show: true,
            message: error.response.data?.message,
            severity: 'error'
          })
        );
      }

      return thunkApi.rejectWithValue(error);
    }
  }
);

// get auto schedule trip details
export const scheduleTripsAction = createAsyncThunk<ReturnedType, Trips>(
  'auto schedule trips/trips',
  async (payload, thunkApi) => {
    try {
      const response = await axiosInstance({
        method: 'GET',
        // url: `${URLs.GET_AUTO_PLANNERTRIP_SCHEDULE}/bookings?date=${payload.date}&mode=${payload.mode}&tourName=${payload.tourName}&vehicleNumber=${payload.vehicleNumber}&id=${payload.id}`
        url: `${URLs.GET_AUTO_PLANNERTRIP_SCHEDULE}/bookings?date=${payload.date}&mode=${payload.mode}&id=${payload.id}`
        // url: `${URLs.GET_AUTO_PLANNERTRIP_SCHEDULE}/bookings?date=1717785000&mode=SIC&id=CITY TOUR-pc6211-0`
      });
      if (response?.data?.status === 'Not found') {
        thunkApi.dispatch(
          updateToast({
            show: true,
            message: 'No trip report on this date',
            severity: 'warning'
          })
        );
      }
      return response?.data;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.message,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

// get auto switch trip details
export const switchTripsAction = createAsyncThunk<ReturnedType, any>(
  'auto switch trips/trips',
  async (params, thunkApi) => {
    const {
      autoplannerID,
      tripMode,
      PageNo,
      PageSize,
      agentName,
      guestName,
      tourName,
      vehicleNumber,
      searchFor,
      pageNo,
      pageSize,
      search
    } = params;
    try {
      let url = `${
        URLs.GET_AUTO_PLANNERTRIP_SWITCH
      }date=${autoplannerID}&mode=${tripMode}&pageNo=${PageNo ?? pageNo}&pageSize=${
        PageSize ?? pageSize
      }`;
      if (searchFor || search) {
        url += `&searchFor=${searchFor ?? search}`;
      }
      const optionalParams = [
        { key: 'agentName', value: agentName },
        { key: 'guestName', value: guestName },
        { key: 'tourName', value: tourName },
        { key: 'vehicleNumber', value: vehicleNumber }
      ];

      optionalParams.forEach(param => {
        if (param.value) {
          url += `&${param.key}=${param.value}`;
        }
      });

      const response = await axiosInstance({
        method: 'GET',
        url: url
      });
      if (response?.data?.status === 'Not found') {
        thunkApi.dispatch(
          updateToast({
            show: true,
            message: 'No trip report on this date',
            severity: 'warning'
          })
        );
      }
      return response?.data;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.message,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

export const getScheduleDriverAction = createAsyncThunk<AxiosResponse<any>, any>(
  'get Schedule Driver',
  async (params, thunkApi) => {
    const { date, mode, journeyId: journeyID, driverID, modifyVehicleDriver } = params;

    const queryParams: Record<string, string | number | boolean | undefined> = {
      date,
      mode,
      journeyID,
      driverID,
      modifyVehicleDriver
    };

    const filteredParams = Object.entries(queryParams)
      .filter(([key, value]) => value !== undefined && value !== null && value !== '')
      .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
      .join('&');
    try {
      const response = await axiosInstance({
        method: 'PUT',
        url: `${URLs.GET_SCHEDULED_DRIVER}${filteredParams}`
      });
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: response.data?.message,
          severity: 'success'
        })
      );
      return response?.data;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.message,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

// driver details slice
const scheduledDriverSlice = createSlice({
  name: 'scheduled driver',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(getScheduleDriverAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        getScheduleDriverAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload;
          state.error = null;
        }
      )
      .addCase(getScheduleDriverAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error;
      });
  }
});

// get mode vehicle details
export const modeVehicleAction = createAsyncThunk<AxiosResponse<any>, string>(
  'autoplannermodevehicle',
  async (mode, thunkApi) => {
    try {
      const response = await axiosInstance({
        method: 'GET',
        url: `${URLs.GET_MODE_VEHICLE}mode=${mode}`
      });
      return response?.data;
    } catch (error: any) {
      return thunkApi.rejectWithValue(error);
    }
  }
);

//Action for Send Notification
export const sendAgentNotification = createAsyncThunk<AxiosResponse<any>, any>(
  'notificationForAgent',
  async (data, thunkApi) => {
    try {
      const response = await axiosInstance({
        method: 'POST',
        url: `${URLs.SENT_AGENT_NOTIFICATION}date=${data.date}`
      });
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: response?.data?.message,
          severity: 'success'
        })
      );
      return response?.data;
    } catch (error: any) {
      return thunkApi.rejectWithValue(error);
    }
  }
);

//Slice for Send Agent Notofication
const agentNotificationTask = createSlice({
  name: 'agentNotification',
  initialState: initialStates,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(sendAgentNotification.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        sendAgentNotification.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload.data;
          state.error = null;
        }
      )
      .addCase(sendAgentNotification.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error;
      });
  }
});

// get tour agent dropdown for filter
export const tourAgentDropdown = createAsyncThunk<AxiosResponse<any>, any>(
  'filterAgentTourDropdown',
  async (data, thunkApi) => {
    try {
      const response = await axiosInstance({
        method: 'GET',
        url: `${URLs.GET_TOURAGENT_DROPDOWN}date=${data.date}&mode=${data.mode}`
      });
      return response?.data;
    } catch (error: any) {
      return thunkApi.rejectWithValue(error);
    }
  }
);

// slice for get tour agent dropdown
const tourAgentDrpdownSlice = createSlice({
  name: 'filterAgentTourDropdwon',
  initialState: initialStates,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(tourAgentDropdown.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        tourAgentDropdown.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload.data;
          state.error = null;
        }
      )
      .addCase(tourAgentDropdown.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error;
      });
  }
});

//get Driver Dropdown
export const driverDropdownAction = createAsyncThunk<AxiosResponse<any>, any>(
  'transferDriver',
  async (data, thunkApi) => {
    try {
      const baseURL =
        data?.radio === false
          ? `${URLs.GET_DRIVEDROPDOWN}/all`
          : `${URLs.GET_DRIVEDROPDOWN}`;

      const params = new URLSearchParams();
      params.append('date', data.date);
      params.append('mode', data.mode);
      params.append('vehicleNumber', data.vehicleNumber);
      params.append('tourName', data.tourName);
      params.append('journeyID', data?.journeyId ?? '');
      const finalURL = `${baseURL}?${params.toString()}`;
      const response = await axiosInstance({
        method: 'GET',
        url: finalURL
      });
      return response?.data;
    } catch (error: any) {
      return thunkApi.rejectWithValue(error);
    }
  }
);

// Slice for Driver Dropdown
const driverSlice = createSlice({
  name: 'autoplannermodevehilce',
  initialState: initialStates,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(driverDropdownAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        driverDropdownAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload.data;
          state.error = null;
        }
      )
      .addCase(driverDropdownAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error;
      });
  }
});

// Action function to update trip
export const autoGenerateUpdateTripsAction = createAsyncThunk<ReturnedType, any>(
  'updateautogeneratedtrips',
  async (data, thunkApi) => {
    const { payload, pageDetails: rest } = data;

    try {
      const response = await axiosInstance({
        method: 'PUT',
        url: `${URLs.SCHEDULE_UPDATE}?date=${rest.autoplannerID}&mode=${
          rest.tripMode
        }&isCurrentSchedule=${rest?.isCurrentSchedule || false}`,
        data: payload
      });
      await thunkApi.dispatch(autoGeneratedTripsAction(rest));
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: response?.data?.message,
          severity: 'success'
        })
      );
      return response?.data?.data[0];
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.message || error.response.data?.error,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

//action for Update guest contact number
export const guestContactUpdateAction = createAsyncThunk<ReturnedType, any>(
  'guestContactUpdate',
  async (data, thunkApi) => {
    try {
      const response = await axiosInstance({
        method: 'PUT',
        url: `${URLs.UPDATE_SHARE_TRIP}`,
        data
      });

      thunkApi.dispatch(
        updateToast({
          show: true,
          message: response?.data?.message,
          severity: 'success'
        })
      );
      return response?.data?.data[0];
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.message || error.response.data?.error,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

// Slice for update guest Contact Number
const updateContactSlice = createSlice({
  name: 'guest contact update',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(guestContactUpdateAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        guestContactUpdateAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload?.data;
          state.error = null;
        }
      )
      .addCase(guestContactUpdateAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error || 'Something went wrong';
      });
  }
});

// Action function to delete trip
export const autoGeneratedDeleteAction = createAsyncThunk<ReturnedType, any>(
  'auto-generated-trip/delete',
  async (data, thunkApi) => {
    try {
      const response = await axiosInstance({
        method: 'DELETE',
        url: `${URLs.GET_AUTO_PLANNERTRIP_SCHEDULE}/groups?autoplannerID=${data?.pageDetails?.autoplannerID}&groupID=${data?.row?.groupId}`
      });
      await thunkApi.dispatch(autoGeneratedTripsAction(data.pageDetails));
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: response?.data?.message,
          severity: 'success'
        })
      );
      return response?.data?.data;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.error,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

//action for send mail
type ThunkArg = any;
export const getPDFExcelReport = createAsyncThunk<ReturnedType, ThunkArg>(
  'sendmail',
  async (data, thunkApi) => {
    const { recipient, date, mail } = data;
    const queryParams: Record<string, string | number | boolean | undefined> = {
      recipient,
      date,
      mail
    };
    const filteredParams = Object.entries(queryParams)
      .filter(([key, value]) => value !== undefined && value !== null && value !== '')
      .map(([key, value]) => {
        if (key === 'mail') {
          return `${key}=${value}`;
        }
        return `${key}=${encodeURIComponent(String(value))}`;
      })
      .join('&');
    try {
      const response = await axiosInstance({
        method: 'POST',
        url: `${URLs.AUTOPLANNER_REPORT}${filteredParams}`,
        data
      });

      if (response) {
        thunkApi.dispatch(
          updateToast({
            show: true,
            message: response?.data?.message,
            severity: 'success'
          })
        );
      }
      return response;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error?.response?.data?.message || error?.response?.data?.error,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

//Action for update Autogenerate bookings update
export const updateAutoGenerateBookingsAction = createAsyncThunk<ReturnedType, any>(
  'updateAutoGenerateBookingd',
  async (data, thunkApi) => {
    try {
      const response = axiosInstance({
        method: 'PUT',
        url: `${URLs.SCHEDULE_UPDATE_BOOKINGS}`,
        data
      });
      return response;
    } catch (error) {
      return thunkApi.rejectWithValue(error);
    }
  }
);

// Action function to delete bookings
export const autoGeneratedBookingDeleteAction = createAsyncThunk<ReturnedType, any>(
  'auto-generated-booking/delete',
  async (data, thunkApi) => {
    const payload = {
      groupID: data?.group.groupId,
      date: data?.pageDetails?.autoplannerID
    };
    try {
      const response = await axiosInstance({
        method: 'DELETE',
        url: `${URLs.GET_AUTO_PLANNERTRIP_SCHEDULE}/bookings?tripID=${data?.row?.trip_id}&journeyID=${data?.row?.journey_id}`
      });
      // await thunkApi.dispatch(scheduleTripsAction(payload));
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: response?.data?.message,
          severity: 'success'
        })
      );
      return response?.data?.data;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.error,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

// auto planner mode vehicle slice
const modeVehicleSlice = createSlice({
  name: 'autoplannermodevehilce',
  initialState: initialStates,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(modeVehicleAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        modeVehicleAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload.data;
          state.error = null;
        }
      )
      .addCase(modeVehicleAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error;
      });
  }
});

// auto generated trips details slice
const autoGeneratedTripsSlice = createSlice({
  name: 'autogeneratedtrips',
  initialState: initialStates,
  reducers: {
    clearPVTandGRP: state => {
      state.data = [];
    }
  },
  extraReducers: builder => {
    builder
      .addCase(autoGeneratedTripsAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        autoGeneratedTripsAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload.data;
          state.error = null;
        }
      )
      .addCase(autoGeneratedTripsAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error;
      });
  }
});

// auto schedule trips details slice
const scheduleTripsSlice = createSlice({
  name: 'scheduleTrips',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(scheduleTripsAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        scheduleTripsAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload;

          state.error = null;
        }
      )
      .addCase(scheduleTripsAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error;
      });
  }
});

// auto switch trips details slice
const switchTripsSlice = createSlice({
  name: 'switchTrips',
  initialState,
  reducers: {
    setFilter: (state, action) => {
      state.isFilter = action.payload;
    },
    clearScheduleData: state => {
      state.data = null;
    }
  },
  extraReducers: builder => {
    builder
      .addCase(switchTripsAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        switchTripsAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          const {
            data: { scheduledBookingResponses, count }
          } = action.payload;
          state.data = scheduledBookingResponses;
          state.count = count;
          state.error = null;
        }
      )
      .addCase(switchTripsAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error;
      });
  }
});

// Update auto generate trips slice
const updateAutoGeneratedTrip = createSlice({
  name: 'auto generate trips update',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(autoGenerateUpdateTripsAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        autoGenerateUpdateTripsAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload?.data;
          state.error = null;
        }
      )
      .addCase(autoGenerateUpdateTripsAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error || 'Something went wrong';
      });
  }
});

// delete auto generate trips slice
const deleteAutoGeneratedSlice = createSlice({
  name: 'auto generate trips delete',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(autoGeneratedDeleteAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        autoGeneratedDeleteAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload?.data;
          state.error = null;
        }
      )
      .addCase(autoGeneratedDeleteAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error || 'Something went wrong';
      });
  }
});

// delete auto generate booking slice
const deleteAutoGeneratedBookingSlice = createSlice({
  name: 'auto generate booking delete',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(autoGeneratedBookingDeleteAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        autoGeneratedBookingDeleteAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload?.data;
          state.error = null;
        }
      )
      .addCase(autoGeneratedBookingDeleteAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error || 'Something went wrong';
      });
  }
});

//send mail slice
const getPDFExcelReportSlice = createSlice({
  name: 'sendmail',
  initialState: pdfExcelState,
  reducers: {},
  extraReducers: builder => {
    builder.addCase(getPDFExcelReport.pending, state => {
      state.isLoading = true;
    });
    builder.addCase(getPDFExcelReport.fulfilled, (state, action) => {
      state.isLoading = false;
      state.data = action.payload;
    });
    builder.addCase(getPDFExcelReport.rejected, (state, action: any) => {
      state.isLoading = false;
      state.error = action?.payload?.response?.data?.error || 'Network error';
    });
  }
});

//Slice for update autogenerate trips
const updateAutoGenerateBookingssSlice = createSlice({
  name: 'updatebookings',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(updateAutoGenerateBookingsAction.pending, state => {
        state.isLoading = true;
        state.data = null;
        state.error = null;
      })
      .addCase(updateAutoGenerateBookingsAction.fulfilled, (state, action) => {
        state.isLoading = false;
        state.data = action.payload.data;
      })
      .addCase(updateAutoGenerateBookingsAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action?.payload?.response?.data?.error;
      });
  }
});

// delete schedule
export const deleteSchedule = createAsyncThunk<ReturnedType, ThunkArg>(
  'delete/schedule',
  async (data, thunkApi) => {
    const { date, mode, id } = data;
    try {
      const response = await axiosInstance({
        method: 'DELETE',
        url: `${URLs.SCHEDULE_DELETE}?date=${date}&mode=${mode}&id=${id}`
      });
      await thunkApi.dispatch(
        autoGeneratedTripsAction({ autoplannerID: date, tripMode: mode } as any)
      );
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: response?.data?.message,
          severity: 'success'
        })
      );
      return response?.data?.data;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.message || error.response.data?.error,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

// delete schedule slice
const deleteScheduleSlice = createSlice({
  name: 'deleteSchedule',
  initialState: initialState,
  reducers: {},
  extraReducers: builder => {
    builder.addCase(deleteSchedule.pending, state => {
      state.isLoading = true;
      state.error = null;
    });
    builder.addCase(
      deleteSchedule.fulfilled,
      (state, action: PayloadAction<ReturnedType>) => {
        state.isLoading = false;
        state.data = action.payload?.data;
        state.error = null;
      }
    );
    builder.addCase(deleteSchedule.rejected, (state, action: any) => {
      state.isLoading = false;
      state.error = action.payload?.response?.data?.error || 'Something went wrong';
    });
  }
});

// delete schedule booking
export const deleteScheduleBooking = createAsyncThunk<ReturnedType, ThunkArg>(
  'delete/schedulebooking',
  async (data, thunkApi) => {
    const { date, journeyId, mode, id } = data;
    try {
      const response = await axiosInstance({
        method: 'DELETE',
        url: `${URLs.SCHEDULE_BOOKING_DELETE}?date=${date}&journeyId=${journeyId}&mode=${mode}`
      });
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: response?.data?.message,
          severity: 'success'
        })
      );
      return response?.data?.data;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.message || error.response.data?.error,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

// delete schedule booking slice
const deleteScheduleBookingSlice = createSlice({
  name: 'deleteScheduleBooking',
  initialState: initialState,
  reducers: {},
  extraReducers: builder => {
    builder.addCase(deleteScheduleBooking.pending, state => {
      state.isLoading = true;
      state.error = null;
    });
    builder.addCase(
      deleteScheduleBooking.fulfilled,
      (state, action: PayloadAction<ReturnedType>) => {
        state.isLoading = false;
        state.data = action.payload?.data;
        state.error = null;
      }
    );
    builder.addCase(deleteScheduleBooking.rejected, (state, action: any) => {
      state.isLoading = false;
      state.error = action.payload?.response?.data?.error || 'Something went wrong';
    });
  }
});

// Action function to update SIC bookings
export const sicBookingsUpdate = createAsyncThunk<ReturnedType, any>(
  'sicBookingsUpdate',
  async (data, thunkApi) => {
    const {
      payload,
      pageDetails: { ...rest }
    } = data;
    try {
      const response = await axiosInstance({
        method: 'PUT',
        url: `${URLs.SIC_BOOKINGS_UPDATE}?date=${data.pageDetails.autoplannerID}&mode=${data.pageDetails.tripMode}`,
        data: payload
      });
      // await thunkApi.dispatch(
      //   scheduleTripsAction({
      //     date: data.pageDetails.autoplannerID,
      //     mode: data.pageDetails.tripMode,
      //     id: data.pageDetails.id
      //   } as any)
      // );
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: response?.data?.message,
          severity: 'success'
        })
      );
      return response?.data?.data[0];
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.message || error.response.data?.error,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

// Action function to update PVT and GRP Scheduled Trips
export const PvtGrpUpdate = createAsyncThunk<ReturnedType, any>(
  'PVTGrpUpdate/put',
  async (data, thunkApi) => {
    const {
      payload,
      todatTrips,
      pageDetails: { ...rest }
    } = data;
    try {
      const response = await axiosInstance({
        method: 'PUT',
        url: `${URLs.PVT_GRP_UPDATE}?date=${data.pageDetails.autoplannerID}&mode=${
          data.pageDetails.tripMode
        }&isCurrentSchedule=${data?.pageDetails?.isCurrentSchedule || false}`,
        data: payload
      });
      if (!todatTrips) {
        await thunkApi.dispatch(
          autoGeneratedTripsAction({
            autoplannerID: data.pageDetails.autoplannerID,
            tripMode: data.pageDetails.tripMode,
            PageNo: data.pageDetails.pageNo,
            PageSize: data.pageDetails.pageSize
          } as any)
        );
      }
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: response?.data?.message,
          severity: 'success'
        })
      );
      return response;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error?.response?.data?.message || error.response.data?.error,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

// Update sic bookings slice
const sicBookingsUpdateSlice = createSlice({
  name: 'sicBookingsUpdate',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(sicBookingsUpdate.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        sicBookingsUpdate.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload?.data;
          state.error = null;
        }
      )
      .addCase(sicBookingsUpdate.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error || 'Something went wrong';
      });
  }
});

// Update PVT and GRP Scheduled trips slice
const PVTschudleUpdateSlice = createSlice({
  name: 'PVTGrpUpdate',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(PvtGrpUpdate.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(PvtGrpUpdate.fulfilled, (state, action: PayloadAction<ReturnedType>) => {
        state.isLoading = false;
        state.data = action.payload?.data;
        state.error = null;
      })
      .addCase(PvtGrpUpdate.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error || 'Something went wrong';
      });
  }
});

// get vehicle number
export const getStandardVehicles = createAsyncThunk<any, any>(
  'standard/vehicles',
  async (data, thunkApi) => {
    const {
      autoplannerID: autoplannerid,
      tripMode: mode,
      tourName,
      journeyId: journeyID,
      totalPassengers: totalSeating,
      vehicleNumber,
      isCurrentSchedule = false
    } = data;

    // if (!mode || !journeyID) {
    //   return thunkApi.rejectWithValue('Mode and JourneyID are required');
    // }

    const queryParams: Record<string, string | number | boolean | undefined> = {
      autoplannerid,
      mode,
      tourName,
      totalSeating,
      journeyID,
      vehicleNumber,
      isCurrentSchedule
    };

    const filteredParams = Object.entries(queryParams)
      .filter(([key, value]) => value !== undefined && value !== null)
      .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
      .join('&');
    try {
      let url = `${URLs.STANDARD_VEHICLES}?${filteredParams}`;

      const response = await axiosInstance({
        method: 'GET',
        url: url
      });
      return response?.data?.data;
    } catch (error: any) {
      return thunkApi.rejectWithValue(error);
    }
  }
);

// get driver name
export const getStandardDriverNames = createAsyncThunk<any, any>(
  'standard/driverName',
  async (data, thunkApi) => {
    const {
      autoplannerID: date,
      tripMode: mode,
      tourName,
      journeyId: journeyID,
      vehicleNumber,
      isCurrentSchedule = false,
      assignedVehicle
    } = data;

    const queryParams: Record<string, string | number | boolean | undefined> = {
      date,
      mode,
      tourName,
      journeyID,
      vehicleNumber,
      isCurrentSchedule,
      assignedVehicle
    };

    const filteredParams = Object.entries(queryParams)
      .filter(([key, value]) => value !== undefined && value !== null)
      .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
      .join('&');

    try {
      let url = `${URLs.TODAY_DRIVER_DROPDOWN}?${filteredParams}`;
      const response = await axiosInstance({
        method: 'GET',
        url: url
      });
      return response?.data?.data;
    } catch (error: any) {
      return thunkApi.rejectWithValue(error);
    }
  }
);

// get vehicle number slice
export const getStandardVehiclesSlice = createSlice({
  name: 'getStandardVehicles',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(getStandardVehicles.pending, state => {
        state.isLoading = true;
        state.data = [];
      })
      .addCase(getStandardVehicles.fulfilled, (state, action: PayloadAction<any>) => {
        state.isLoading = false;
        state.data = action.payload;
        state.error = null;
      })
      .addCase(getStandardVehicles.rejected, (state, action: any) => {
        state.isLoading = false;
        state.data = [];
        state.error = action.payload?.response?.data.error || 'Something went wrong';
      });
  }
});

// get vehicle number slice
export const getStandardDriverNamesSlice = createSlice({
  name: 'getStandardDriverName',
  initialState,
  reducers: {
    clearDriverNames: state => {
      state.data = null;
    }
  },
  extraReducers: builder => {
    builder
      .addCase(getStandardDriverNames.pending, state => {
        state.isLoading = true;
        state.data = [];
      })
      .addCase(getStandardDriverNames.fulfilled, (state, action: PayloadAction<any>) => {
        state.isLoading = false;
        state.data = action.payload;
        state.error = null;
      })
      .addCase(getStandardDriverNames.rejected, (state, action: any) => {
        state.isLoading = false;
        state.data = [];
        state.error = action.payload?.response?.data.error || 'Something went wrong';
      });
  }
});

//Action for Vehicle Dropdown in Filter
export const filterVehicleAction = createAsyncThunk<AxiosResponse<any>, any>(
  'filterVehicle',
  async (data, thunkApi) => {
    try {
      const response = await axiosInstance({
        method: 'GET',
        url: `${URLs.GET_VEHICLE_DROPDOWN}mode=${data.tripMode}&date=${data.autoplannerID}`
      });
      return response?.data;
    } catch (error: any) {
      return thunkApi.rejectWithValue(error);
    }
  }
);

//Slice for Vehicle Dropdown in Filter
const filterVehicleSlice = createSlice({
  name: 'filterVehicle',
  initialState: initialStateDropDown,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(filterVehicleAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        filterVehicleAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload.data;
          state.error = null;
        }
      )
      .addCase(filterVehicleAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error;
      });
  }
});

// action for excel get
export const getExcelAction = createAsyncThunk<ReturnedType, any>(
  'getExcelAction',
  async (params, thunkApi) => {
    const {
      autoplannerID,
      tripMode,
      PageNo,
      PageSize,
      agentName,
      guestName,
      tourName,
      vehicleNumber,
      searchFor
    } = params;
    try {
      let url = `${URLs.GET_EXCEL}date=${autoplannerID}&mode=${tripMode}&pageNo=${PageNo}&pageSize=${PageSize}`;
      if (searchFor) {
        url += `&searchFor=${encodeURIComponent(searchFor)}`;
      }
      const optionalParams = [
        { key: 'agentName', value: agentName },
        { key: 'guestName', value: guestName },
        { key: 'tourName', value: tourName },
        { key: 'vehicleNumber', value: vehicleNumber }
      ];

      optionalParams.forEach(param => {
        if (param.value) {
          url += `&${param.key}=${param.value}`;
        }
      });

      const response = await axiosInstance({
        method: 'GET',
        url: url
      });
      if (response?.data?.status === 'Not found') {
        thunkApi.dispatch(
          updateToast({
            show: true,
            message: 'No trip report on this date',
            severity: 'warning'
          })
        );
      }
      return response?.data;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.message,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

// slice for get excel
const getExcelSlice = createSlice({
  name: 'getExcelSlice',
  initialState,
  reducers: {
    setFilter: (state, action) => {
      state.isFilter = action.payload;
    },
    clearExcelView: state => {
      state.data = [];
      state.statusCount = {};
    }
  },
  extraReducers: builder => {
    builder
      .addCase(getExcelAction.pending, state => {
        state.isLoading = true;
        state.error = null;
        // state.data = [];
        // state.statusCount = {};
      })
      .addCase(getExcelAction.fulfilled, (state, action: PayloadAction<ReturnedType>) => {
        state.isLoading = false;
        const {
          data: {
            scheduledBookingResponses,
            count,
            statusAggregateSum: {
              Upcoming = 0,
              Intransit = 0,
              Completed = 0,
              Skipped: tripSkipped = 0
            },
            bookingsOnboardedMap
          }
        } = action.payload;

        const {
          Onboarded = 0,
          Pending = 0,
          No_show = 0,
          Skipped = 0
        } = bookingsOnboardedMap;
        state.data = scheduledBookingResponses;
        state.statusCount = {
          Upcoming: Upcoming ?? 0,
          'In-transit': Intransit ?? 0,
          Completed: Completed ?? 0,
          'Trip Skipped': tripSkipped ?? 0,
          Total: Onboarded + (Pending ?? 0) + (No_show ?? 0) + Skipped,
          Onboarded: Onboarded ?? 0,
          Skipped: Skipped ?? 0,
          'No show': No_show ?? 0,
          'Yet to onboard': Pending ?? 0
        };
        state.count = count;
        state.error = null;
      })
      .addCase(getExcelAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error;
      });
  }
});

interface HotelsPayload {
  mode: string;
  date: number;
  journeyID: string;
}

//action for send whatsapp
export const sendwhatsappAction = createAsyncThunk<ReturnedType, ThunkArg>(
  'whatsapp',
  async (data, thunkApi) => {
    const { autoplannerId, skippingPhoneNumber, journeyId } = data;
    const queryParams: Record<string, string | number | boolean | undefined> = {
      autoplannerId,
      skippingPhoneNumber,
      journeyId
    };
    const filteredParams = Object.entries(queryParams)
      .filter(([key, value]) => value !== undefined && value !== null && value !== '')
      .map(([key, value]) => {
        if (key === 'mail') {
          return `${key}=${value}`;
        }
        return `${key}=${encodeURIComponent(String(value))}`;
      })
      .join('&');
    try {
      const response = await axiosInstance({
        method: 'POST',
        url: `${URLs.SEND_WHATSAPP}${filteredParams}`,
        data
      });

      if (response?.data?.message != 'missing guest contact numbers') {
        thunkApi.dispatch(
          updateToast({
            show: true,
            message: response?.data?.message,
            severity: 'success'
          })
        );
      }
      return response;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error?.response?.data?.message || error?.response?.data?.error,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

// send whats app
const sendwhatsappSlice = createSlice({
  name: 'sendwhatsapp',
  initialState: initialStates,
  reducers: {
    clearWhatsapp: state => {
      state.data = null;
    }
  },
  extraReducers: builder => {
    builder
      .addCase(sendwhatsappAction.pending, state => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        sendwhatsappAction.fulfilled,
        (state, action: PayloadAction<ReturnedType>) => {
          state.isLoading = false;
          state.data = action.payload.data;
          state.error = null;
        }
      )
      .addCase(sendwhatsappAction.rejected, (state, action: any) => {
        state.isLoading = false;
        state.error = action.payload?.response?.data?.error;
      });
  }
});

//action to get main hotel List
export const getMainHotelsList = createAsyncThunk<any, HotelsPayload>(
  'hotels/dropdown',
  async (data, thunkApi) => {
    try {
      const { mode, date, journeyID } = data;
      const response = axiosInstance({
        method: 'GET',
        url: `${URLs.GET_MAIN_HOTELS}mode=${mode}&date=${date}&journeyID=${journeyID}`
      });
      return (await response).data.data;
    } catch (error) {
      thunkApi.rejectWithValue(error);
    }
  }
);

//slice to get main hotels
const getMainHotelsSlice = createSlice({
  name: 'hotels',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(getMainHotelsList.pending, state => {
        state.isLoading = true;
        state.data = null;
        state.error = null;
      })
      .addCase(getMainHotelsList.fulfilled, (state, action: PayloadAction<any>) => {
        state.isLoading = false;
        state.data = action.payload;
      })
      .addCase(getMainHotelsList.rejected, (state, action: PayloadAction<any>) => {
        state.isLoading = false;
        state.error = action.payload.response.data.error;
      });
  }
});

// delete schedule booking
export const publishTripsAction = createAsyncThunk<ReturnedType, ThunkArg>(
  'publish/schedulebooking',
  async (data, thunkApi) => {
    const { date, isMail, isWhatsapp } = data;
    try {
      const response = await axiosInstance({
        method: 'POST',
        url: `${
          URLs.PUBLISH_TRIPS
        }date=${date}&bulkMailAgents=${isMail}&whatsappGuests=${isWhatsapp}&publish=${1}`
      });
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: response?.data?.message,
          severity: 'success'
        })
      );
      return response?.data?.data;
    } catch (error: any) {
      thunkApi.dispatch(
        updateToast({
          show: true,
          message: error.response.data?.message || error.response.data?.error,
          severity: 'error'
        })
      );
      return thunkApi.rejectWithValue(error);
    }
  }
);

// delete schedule booking slice
const publishBookingsSlice = createSlice({
  name: 'publishBookings',
  initialState: initialState,
  reducers: {},
  extraReducers: builder => {
    builder.addCase(publishTripsAction.pending, state => {
      state.isLoading = true;
      state.error = null;
    });
    builder.addCase(
      publishTripsAction.fulfilled,
      (state, action: PayloadAction<ReturnedType>) => {
        state.isLoading = false;
        state.data = action.payload?.data;
        state.error = null;
      }
    );
    builder.addCase(publishTripsAction.rejected, (state, action: any) => {
      state.isLoading = false;
      state.error = action.payload?.response?.data?.error || 'Something went wrong';
    });
  }
});

export const autoPlannerReportSlice = getPDFExcelReportSlice.reducer;
export const publishTrips = publishBookingsSlice.reducer;
export const guestContactUpdate = updateContactSlice.reducer;
export const notifyAgent = agentNotificationTask.reducer;
export const sendwhatsapp = sendwhatsappSlice.reducer;
export const agentTourDropdown = tourAgentDrpdownSlice.reducer;
export const driverChange = scheduledDriverSlice.reducer;
export const transferDriver = driverSlice.reducer;
export const filterVehicle = filterVehicleSlice.reducer;
export const autoGeneratedTripSlice = autoGeneratedTripsSlice.reducer;
export const modeVehicle = modeVehicleSlice.reducer;
export const PVTGRPScheduleUpdate = PVTschudleUpdateSlice.reducer;
export const scheduleTripSlice = scheduleTripsSlice.reducer;
export const switchTripSlice = switchTripsSlice.reducer;
export const getExcelReducer = getExcelSlice.reducer;
export const updateAutoGeneratedTripSlice = updateAutoGeneratedTrip.reducer;
export const deleteAutoGeneratedSliceSlice = deleteAutoGeneratedSlice.reducer;
export const deleteAutoGeneratedBooking = deleteAutoGeneratedBookingSlice.reducer;
export const deleteScheduleReducer = deleteScheduleSlice.reducer;
export const deleteScheduleBookingReducer = deleteScheduleBookingSlice.reducer;
export const sicBookingsUpdateReducer = sicBookingsUpdateSlice.reducer;
export const getStandardVehiclesReducer = getStandardVehiclesSlice.reducer;
export const getStandardDriverNamesReducer = getStandardDriverNamesSlice.reducer;
export const getMainHotelsData = getMainHotelsSlice.reducer;
export const { setFilter, clearScheduleData } = switchTripsSlice.actions;
export const { clearPVTandGRP } = autoGeneratedTripsSlice.actions;
export const { clearExcelView } = getExcelSlice.actions;
export const { clearWhatsapp } = sendwhatsappSlice.actions;
export const { clearDriverNames } = getStandardDriverNamesSlice.actions;
